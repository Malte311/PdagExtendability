var documenterSearchIndex = {"docs":
[{"location":"extendability/#extendability_header","page":"Extension Problem","title":"Extension Problem","text":"","category":"section"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"The main component of this framework is composed of algorithms for the extension problem. That is, given a partially directed graph, compute a consistent DAG extension if possible, otherwise return a negative answer.","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"Some algorithms have been implemented in two variants. The first variant uses HashSets internally while the second one uses the LightGraphs library internally. It is noteworthy that the implementation using HashSets has a better performance in general and thus not all algorithms have been implemented using the LightGraphs library internally.","category":"page"},{"location":"extendability/#Implementation-using-the-LightGraphs-Library","page":"Extension Problem","title":"Implementation using the LightGraphs Library","text":"","category":"section"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"Since the performance of the implementation with LightGraphs is inferior to the performance of the HashSets implementation, not all algorithms have been implemented using LightGraphs. Available algorithms are:","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"pdag2dag_lg - An algorithm with worst-case time complexity O(Delta^2 E).\nfastpdag2dag_lg - An algorithm with worst-case time complexity O(Delta E).","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"All of the other functions that are listed below are called internally in these algorithms.","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"Modules = [PdagExtendability]\nPages = [\n\t\"extendability/implementation_lg/dor_tarsi_algo_lg.jl\",\n\t\"extendability/implementation_lg/new_algo_datastructure_lg.jl\",\n\t\"extendability/implementation_lg/new_algo_lg.jl\",\n\t\"extendability/implementation_lg/new_algo_optimization_lg.jl\",\n]","category":"page"},{"location":"extendability/#PdagExtendability.pdag2dag_lg-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.pdag2dag_lg","text":"pdag2dag_lg(g::SimpleDiGraph)::SimpleDiGraph\n\nConvert a partially directed acyclic graph (PDAG) into a fully directed acyclic graph (DAG). If this is not possible, an empty graph is returned.\n\nUndirected edges are represented as two directed edges.\n\nReferences\n\nD. Dor, M. Tarsi (1992). A simple algorithm to construct a consistent extension of a partially oriented graph. Technicial Report R-185, Cognitive Systems Laboratory, UCLA\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> dag = pdag2dag_lg(g)\n{3, 2} directed simple Int64 graph\njulia> collect(edges(dag))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.sink_lg-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.sink_lg","text":"sink_lg(g::SimpleDiGraph)::Int64\n\nFind a sink in a partially directed graph. The sink has no outgoing edges and all vertices connected to it via an undirected edge are adjacent to all adjacent vertices of the sink. If no sink is found, -1 is returned.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> x = sink_lg(g)\n3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.Graph","page":"Extension Problem","title":"PdagExtendability.Graph","text":"The datastructure to store a partially directed graph, using the LightGraphs library internally.\n\n\n\n\n\n","category":"type"},{"location":"extendability/#PdagExtendability.init_auxvectors_lg!-Tuple{PdagExtendability.Graph}","page":"Extension Problem","title":"PdagExtendability.init_auxvectors_lg!","text":"init_auxvectors_lg!(g::Graph)\n\nInitialize the auxilliary vectors for the given graph g.\n\nExamples\n\njulia> g = init_lg(SimpleDiGraph(3))\nGraph(\n\t{3, 0} directed simple Int64 graph,\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[0, 0, 0]\n)\njulia> init_auxvectors_lg!(g)\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.init_lg","page":"Extension Problem","title":"PdagExtendability.init_lg","text":"init_lg(g::SimpleDiGraph, emptygraph::Bool = false)::Graph\n\nAllocate memory for the HybridGraph datastructure representing a graph with n vertices. The datastructure holds a copy of the input graph g. This can be disabled by setting emptygraph to true.\n\nExamples\n\njulia> g = init_lg(SimpleDiGraph(3))\nGraph(\n\t{3, 0} directed simple Int64 graph,\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[0, 0, 0]\n)\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.insert_arc_lg!","page":"Extension Problem","title":"PdagExtendability.insert_arc_lg!","text":"insert_arc_lg!(graph::Graph, u::Int64, v::Int64, update::Bool = false)\n\nInsert an arc (a directed edge) from u to v into the given graph. If update is set to true, the edge is inserted into graph.g and the values for alpha and beta are updated as well.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> insert_arc_lg!(g, 1, 2)\njulia> is_adjacent_lg(g, 1, 2)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.insert_edge_lg!","page":"Extension Problem","title":"PdagExtendability.insert_edge_lg!","text":"insert_edge_lg!(graph::Graph, u::Int64, v::Int64, update::Bool = false)\n\nInsert an undirected edge between u and v into the given graph. If update is set to true, the edge is inserted into graph.g and the values for alpha and beta are updated as well.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> insert_edge_lg!(g, 2, 3)\njulia> is_adjacent_lg(g, 2, 3)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.is_adjacent_lg-Tuple{PdagExtendability.Graph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.is_adjacent_lg","text":"is_adjacent_lg(graph::Graph, u::Int64, v::Int64)::Bool\n\nCheck whether vertices u and v are adjacent in the given graph.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> is_adjacent_lg(g, 1, 2)\nfalse\njulia> insert_arc_lg!(g, 1, 2)\njulia> is_adjacent_lg(g, 1, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.is_directed_lg-Tuple{PdagExtendability.Graph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.is_directed_lg","text":"is_directed_lg(graph::Graph, u::Int64, v::Int64)::Bool\n\nCheck whether the given graph contains a directed edge from u to v.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> insert_arc_lg!(g, 1, 2)\njulia> is_directed_lg(g, 1, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.is_ps_lg-Tuple{PdagExtendability.Graph, Int64}","page":"Extension Problem","title":"PdagExtendability.is_ps_lg","text":"is_ps_lg(g::Graph, s::Int64)::Bool\n\nDetermine whether s is a potential sink in g.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> is_ps_lg(g, 1)\ntrue\njulia> insert_arc_lg!(g, 1, 2)\njulia> is_ps_lg(g, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.is_undirected_lg-Tuple{PdagExtendability.Graph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.is_undirected_lg","text":"is_undirected_lg(graph::Graph, u::Int64, v::Int64)::Bool\n\nCheck whether the given graph contains an undirected edge between u and v.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> insert_arc_lg!(g, 1, 2)\njulia> is_undirected_lg(g, 1, 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.list_ps_lg-Tuple{PdagExtendability.Graph}","page":"Extension Problem","title":"PdagExtendability.list_ps_lg","text":"list_ps_lg(graph::Graph)::Vector{Int64}\n\nList potential sinks in the given graph.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> list_ps_lg(g)\n3-element Vector{Int64}:\n 1\n 2\n 3\njulia> insert_arc_lg!(g, 1, 2)\njulia> insert_edge_lg!(g, 2, 3)\njulia> list_ps_lg(g)\n1-element Vector{Int64}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.pop_ps_lg!-Tuple{PdagExtendability.Graph, Int64}","page":"Extension Problem","title":"PdagExtendability.pop_ps_lg!","text":"pop_ps_lg!(graph::Graph, s::Int64)::Vector{Int64}\n\nMark s as deleted and delete all edges (directed and undirected) incident to s. Return a list of neighbors of s that became potential sinks after the removal.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> insert_arc_lg!(g, 1, 2)\njulia> insert_edge_lg!(g, 2, 3)\njulia> list_ps_lg(g)\n1-element Vector{Int64}:\n 3\njulia> pop_ps_lg!(g, 3)\n1-element Vector{Int64}:\n 2\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.print_graph_lg","page":"Extension Problem","title":"PdagExtendability.print_graph_lg","text":"print_graph_lg(graph::Graph, io::Core.IO = stdout)\n\nPrint the components of a given graph.\n\nExamples\n\njulia> g = init_lg(1)\n...\njulia> print_graph_lg(g)\nVertex 1:\n        Alpha   = 0     Beta    = 0\n        δ+(G1)  = 0     δ-(G1)  = 0     δ+(G2)  = 0     δ-(G2)  = 0\n        Adj     = \n        In      = \n        Out     = \n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.remove_arc_lg!-Tuple{PdagExtendability.Graph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.remove_arc_lg!","text":"remove_arc_lg!(graph::Graph, u::Int64, v::Int64)\n\nRemove an arc (a directed edge) from u to v from the given graph.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> insert_arc_lg!(g, 1, 2)\njulia> is_adjacent_lg(g, 1, 2)\ntrue\njulia> remove_arc_lg!(g, 1, 2)\njulia> is_adjacent_lg(g, 1, 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.remove_edge_lg!-Tuple{PdagExtendability.Graph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.remove_edge_lg!","text":"remove_edge_lg!(graph::Graph, u::Int64, v::Int64)\n\nRemove an undirected edge between u and v from the given graph.\n\nExamples\n\njulia> g = init_lg(3)\n...\njulia> insert_edge_lg!(g, 2, 3)\njulia> is_adjacent_lg(g, 2, 3)\ntrue\njulia> remove_edge_lg!(g, 2, 3)\njulia> is_adjacent_lg(g, 2, 3)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.update_alphabeta_lg!-Tuple{PdagExtendability.Graph, Int64, Int64, Int64, Bool}","page":"Extension Problem","title":"PdagExtendability.update_alphabeta_lg!","text":"update_alphabeta_lg!(g::Graph, u::Int64, v::Int64, val::Int64, is_uv_dir::Bool)\n\nUpdate values for alpha and beta in g. Either add to (positive value for val) or subtract from (negative value for val) alpha and beta. The parameter isuvdir indicates whether the edge between u and v is directed from u to v.\n\nIs called internally whenever an edge (both directed and undirected) is inserted or removed. Do not call this function by hand.\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.extendgraph_lg-Tuple{PdagExtendability.Graph}","page":"Extension Problem","title":"PdagExtendability.extendgraph_lg","text":"extendgraph_lg(graph::Graph)::SimpleDiGraph\n\nCompute the extension of the given graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> graph = standardsetup_lg(g)\n...\njulia> extendgraph_lg(graph)\n{3, 2} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.fastpdag2dag_lg","page":"Extension Problem","title":"PdagExtendability.fastpdag2dag_lg","text":"fastpdag2dag_lg(g::SimpleDiGraph, optimize::Bool = false)::SimpleDiGraph\n\nConvert a partially directed acyclic graph (PDAG) into a fully directed acyclic graph (DAG). If this is not possible, an empty graph is returned.\n\nUndirected edges are represented as two directed edges.\n\nIf the parameter optimize is omitted or set to false, the algorithm runs in time O(Δm) with Δ being the maximum degree of g and m the number of edges in g. Setting optimize to true will yield an algorithm in time O(dm), where d is the degeneracy of the skeleton.\n\nReferences\n\nM. Wienöbst, M. Bannach, M. Liśkiewicz (2021). Extendability of Causal Graphical Models: Algorithms and Computational Complexity. 37th Conference on Uncertainty in Artificial Intelligence, 2021 (UAI 2021).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> dag = fastpdag2dag_lg(g)\n{3, 2} directed simple Int64 graph\njulia> collect(edges(dag))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.optimizedsetup_lg-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.optimizedsetup_lg","text":"optimizedsetup_lg(g::SimpleDiGraph)::Graph\n\nSet up the datastructure for the algorithm with time complexity O(dm).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> optimizedsetup_lg(g)\nGraph(\n\t{3, 3} directed simple Int64 graph,\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[1, 0, 0],\n\t[0, 1, 1],\n\t[0, 1, 0],\n\t[0, 1, 1]\n)\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.standardsetup_lg-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.standardsetup_lg","text":"standardsetup_lg(g::SimpleDiGraph)::Graph\n\nSet up the datastructure for the algorithm with time complexity O(Δm).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> standardsetup_lg(g)\nGraph(\n\t{3, 3} directed simple Int64 graph,\n\t[0, 0, 0],\n\t[0, 0, 0],\n\t[1, 0, 0],\n\t[0, 1, 1],\n\t[0, 1, 0],\n\t[0, 1, 1]\n)\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.deg_struct_lg-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.deg_struct_lg","text":"deg_struct_lg(g::SimpleDiGraph)::Tuple{Vector{Int64}, Vector{Set{Int64}}}\n\nCompute the degree structure for the graph g. Return a tuple consisting of an array holding the degree for each vertex in g and an array where each index represents a degree (index 1 for degree 0, index 2 for degree 1, ..., index n for degree n-1) and holds a set of vertices which have that degree.\n\nFor example, if we have three vertices 1, 2, 3 with degree 1, 2, and 1, respectively, we obtain the following degree structure: ([1, 2, 1], [Set(), Set([1, 3]), Set([2])])\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> deg_struct_lg(g)\n([1, 2, 1], Set{Int64}[Set(), Set([3, 1]), Set([2])])\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.degeneracy_ordering_lg-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.degeneracy_ordering_lg","text":"degeneracy_ordering_lg(g::SimpleDiGraph)::Tuple{Vector{Int64}, Dict{Int64, Int64}}\n\nCompute a degeneracy ordering for the skeleton of the graph g.\n\nReferences\n\nDavid W. Matula, Leland L. Beck (1983). Smallest-last ordering and clustering and graph coloring algorithms. Journal of the ACM, 30(3):417–427.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> degeneracy_ordering_lg(g)\n([1, 2, 3], Dict(2 => 2, 3 => 3, 1 => 1))\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.pop_min_deg_vertex_lg!-Tuple{Vector{Set{Int64}}}","page":"Extension Problem","title":"PdagExtendability.pop_min_deg_vertex_lg!","text":"pop_min_deg_vertex_lg!(degs::Vector{Set{Int64}})::Int64\n\nFind the vertex with minimum degree in the given degree structure. The vertex will be removed from the structure before returning it. In case there are multiple vertices with the same minimum degree, there is no specific order of choosing them, i.e., any of those vertices is returned.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> (_, degs) = deg_struct_lg(g)\n([1, 2, 1], Set{Int64}[Set(), Set([3, 1]), Set([2])])\njulia> pop_min_deg_vertex_lg!(degs)\n3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.update_deg_lg!-Tuple{Int64, Vector{Int64}, Vector{Set{Int64}}}","page":"Extension Problem","title":"PdagExtendability.update_deg_lg!","text":"update_deg_lg!(v::Int64, aux::Vector{Int64}, degs::Vector{Set{Int64}})\n\nUpdate the degree of a vertex after an adjacent vertex has been removed, i.e., reduce the degree by one and move it into the correct set in the degree structure.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> (aux, degs) = deg_struct_lg(g)\n([1, 2, 1], Set{Int64}[Set(), Set([3, 1]), Set([2])])\njulia> update_deg_lg!(3, aux, degs)\njulia> (aux, degs)\n([1, 2, 0], Set{Int64}[Set([3]), Set([1]), Set([2])])\n\n\n\n\n\n","category":"method"},{"location":"extendability/#Implementation-using-HashSets","page":"Extension Problem","title":"Implementation using HashSets","text":"","category":"section"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"Basically, there are three different algorithms implemented using HashSets internally:","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"pdag2dag_hs - An algorithm with worst-case time complexity O(Delta^2 E).\naltpdag2dag_hs - An alternative implementation for pdag2dag_hs with worst-case time complexity O(Delta^2 E).\nfastpdag2dag_hs - An algorithm with worst-case time complexity O(Delta E).\npdag2mpdag2dag - An algorithm with worst-case time complexity O(Delta E^2) (as the worst-case complexity already suggests, this algorithm is way slower than the other algorithms).","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"Again, all of the other functions listed below are called internally in these algorithms.","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"Modules = [PdagExtendability]\nPages = [\n\t\"extendability/implementation_hs/dor_tarsi_algo_datastructure_hs.jl\",\n\t\"extendability/implementation_hs/dor_tarsi_algo_hs.jl\",\n\t\"extendability/implementation_hs/dor_tarsi_alt_algo_hs.jl\",\n\t\"extendability/implementation_hs/new_algo_datastructure_hs.jl\",\n\t\"extendability/implementation_hs/new_algo_hs.jl\",\n\t\"extendability/implementation_hs/new_algo_optimization_hs.jl\",\n\t\"extendability/implementation_mpdag/pdag2mpdag2dag.jl\"\n]","category":"page"},{"location":"extendability/#PdagExtendability.DtGraph","page":"Extension Problem","title":"PdagExtendability.DtGraph","text":"The datastructure to store a partially directed graph, using HashSets internally.\n\n\n\n\n\n","category":"type"},{"location":"extendability/#PdagExtendability.degree_hs-Tuple{DtGraph, Int64}","page":"Extension Problem","title":"PdagExtendability.degree_hs","text":"degree_hs(graph::DtGraph, u::Int64)::Int64\n\nCompute the degree of vertix u in the given graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> dtgraph = setup_hs(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set()],\n\tSet{Int64}[Set([2]), Set(), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> degree_hs(dtgraph, 1)\n1\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.insert_edge_hs!-Tuple{DtGraph, Int64, Int64, Bool}","page":"Extension Problem","title":"PdagExtendability.insert_edge_hs!","text":"insert_edge_hs!(graph::DtGraph, u::Int64, v::Int64, isdir::Bool)\n\nInsert an edge between u and v into the given graph. The parameter isdir indicates whether the edge is directed or not.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> dtgraph = setup_hs(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set()],\n\tSet{Int64}[Set([2]), Set(), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> insert_edge_hs!(dtgraph, 2, 3, true)\njulia> isadjacent_hs(dtgraph, 3, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.isadjacent_hs-Tuple{DtGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.isadjacent_hs","text":"isadjacent_hs(graph::DtGraph, u::Int64, v::Int64)::Bool\n\nCheck whether vertices u and v are adjacent in the given graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> dtgraph = setup_hs(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set()],\n\tSet{Int64}[Set([2]), Set(), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> isadjacent_hs(dtgraph, 1, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.print_graph_hs","page":"Extension Problem","title":"PdagExtendability.print_graph_hs","text":"print_graph_hs(graph::DtGraph, io::Core.IO = stdout)\n\nPrint a given graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> dtgraph = setup_hs(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set()],\n\tSet{Int64}[Set([2]), Set(), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> print_graph_hs(dtgraph)\nVertex 1:\n        Ingoing    = \n        Outgoing   = 2\n        Undirected = \nVertex 2:\n        Ingoing    = 1\n        Outgoing   = \n        Undirected = \nVertex 3:\n        Ingoing    = \n        Outgoing   = \n        Undirected = \n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.remove_vertex_hs!","page":"Extension Problem","title":"PdagExtendability.remove_vertex_hs!","text":"remove_vertex_hs!(graph::DtGraph, x::Int64, useheuristic::Bool = false)\n\nRemove vertex x from the given graph. Note that this only removes x from sets of other nodes and the sets of x itself are left unchanged, so do not use index x anymore after the removal.\n\nThe parameter useheuristic indicates whether to update the priority queue with vertices' degrees.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> dtgraph = setup_hs(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set()],\n\tSet{Int64}[Set([2]), Set(), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> remove_vertex_hs!(dtgraph, 2)\njulia> dtgraph\nDtGraph(\n\t2,\n\tSet([3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set()],\n\tSet{Int64}[Set(), Set(), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.setup_hs","page":"Extension Problem","title":"PdagExtendability.setup_hs","text":"setup_hs(g::SimpleDiGraph, useheuristic::Bool = false)::DtGraph\n\nInitialize the datastructure from a given graph g.\n\nThe parameter useheuristic indicates whether to maintain a priority queue with vertices' degrees which is used to prefer vertices with low degrees over ones with higher degrees.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> setup_hs(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set()],\n\tSet{Int64}[Set([2]), Set(), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> setup_hs(g, true)\nDtGraph(\n\t3,\n\tSet{Int64}(),\n\tSet{Int64}[Set([3]), Set([2, 1]), Set()],\n\tSet{Int64}[Set(), Set([1]), Set()],\n\tSet{Int64}[Set([2]), Set(), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.pdag2dag_hs","page":"Extension Problem","title":"PdagExtendability.pdag2dag_hs","text":"pdag2dag_hs(g::SimpleDiGraph, useheuristic::Bool = false)::SimpleDiGraph\n\nConvert a partially directed acyclic graph (PDAG) into a fully directed acyclic graph (DAG). If this is not possible, an empty graph is returned.\n\nUndirected edges are represented as two directed edges.\n\nSet useheuristic to true if the algorithm should consider vertices with lower degrees first.\n\nReferences\n\nD. Dor, M. Tarsi (1992). A simple algorithm to construct a consistent extension of a partially oriented graph. Technicial Report R-185, Cognitive Systems Laboratory, UCLA\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> dag = pdag2dag_hs(g)\n{3, 2} directed simple Int64 graph\njulia> collect(edges(dag))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.sink_hs","page":"Extension Problem","title":"PdagExtendability.sink_hs","text":"sink_hs(graph::DtGraph, useheuristic::Bool = false)::Int64\n\nFind a sink in a partially directed graph. The sink has no outgoing edges and all vertices connected to it via an undirected edge are adjacent to all adjacent vertices of the sink. If no sink is found, -1 is returned.\n\nSet useheuristic to true if the algorithm should consider vertices with lower degrees first.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> x = sink_hs(setup_hs(g))\n3\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.altpdag2dag_hs-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.altpdag2dag_hs","text":"altpdag2dag_hs(g::SimpleDiGraph)::SimpleDiGraph\n\nAlternative implementation of pdag2dag_hs. Computes a list of sinks at the beginning. As long as there are sinks left, removes a sink from the graph and checks for all previous neighbors if they became a sink now. If so, adds them to the list of sinks. Terminates when no sinks are left or all vertices are removed.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> dag = altpdag2dag_hs(g)\n{3, 2} directed simple Int64 graph\njulia> collect(edges(dag))\n2-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.is_sink_hs-Tuple{DtGraph, Int64}","page":"Extension Problem","title":"PdagExtendability.is_sink_hs","text":"is_sink_hs(graph::DtGraph, x::Int64)::Bool\n\nCheck whether vertex x is a sink in the given graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> setup = setup_hs(g)\n...\njulia> is_sink_hs(setup, 1)\nfalse\njulia> is_sink_hs(setup, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.list_sinks_hs-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.list_sinks_hs","text":"list_sinks_hs(graph::DtGraph)::Vector{Int64}\n\nCompute a list of sinks in the given graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> setup = setup_hs(g)\n...\njulia> list_sinks_hs(setup)\n1-element Vector{Int64}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.DirectedGraph","page":"Extension Problem","title":"PdagExtendability.DirectedGraph","text":"The datastructure to store a directed graph.\n\n\n\n\n\n","category":"type"},{"location":"extendability/#PdagExtendability.HybridGraph","page":"Extension Problem","title":"PdagExtendability.HybridGraph","text":"The datastructure to store a partially directed graph.\n\n\n\n\n\n","category":"type"},{"location":"extendability/#PdagExtendability.init_hs-Tuple{Int64}","page":"Extension Problem","title":"PdagExtendability.init_hs","text":"init_hs(n::Int64)::HybridGraph\n\nAllocate memory for the HybridGraph datastructure representing a graph with n vertices.\n\nExamples\n\njulia> g = init_hs(3)\nHybridGraph(\n\tDirectedGraph(\n\t\tSet{Int64}[Set(), Set(), Set()],\n\t\t[0, 0, 0],\n\t\t[0, 0, 0],\n\t\tSet{Int64}[Set(), Set(), Set()],\n\t\tSet{Int64}[Set(), Set(), Set()]\n\t),\n\tDirectedGraph(\n\t\tSet{Int64}[Set(), Set(), Set()],\n\t\t[0, 0, 0],\n\t\t[0, 0, 0],\n\t\tSet{Int64}[Set(), Set(), Set()],\n\t\tSet{Int64}[Set(), Set(), Set()]\n\t),\n\t[0, 0, 0],\n\t[0, 0, 0]\n)\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.insert_arc_hs!-Tuple{PdagExtendability.DirectedGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.insert_arc_hs!","text":"insert_arc_hs!(g::DirectedGraph, u::Int64, v::Int64)\n\nInsert an arc (a directed edge) from u to v into g.\n\nIs called internally and should not be called by hand! For inserting arcs, use the function insertarchs! directly on the HybridGraph datastructure instead. ```\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.insert_arc_hs!-Tuple{PdagExtendability.HybridGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.insert_arc_hs!","text":"insert_arc_hs!(g::HybridGraph, u::Int64, v::Int64)\n\nInsert an arc (a directed edge) from u to v into g.\n\nExamples\n\njulia> g = init_hs(3)\n...\njulia> insert_arc_hs!(g, 1, 2)\njulia> is_adjacent_hs(g, 1, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.insert_edge_hs!-Tuple{PdagExtendability.HybridGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.insert_edge_hs!","text":"insert_edge_hs!(g::HybridGraph, u::Int64, v::Int64)\n\nInsert an undirected edge between u and v into g.\n\nExamples\n\njulia> g = init_hs(3)\n...\njulia> insert_edge_hs!(g, 2, 3)\njulia> is_adjacent_hs(g, 2, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.is_adjacent_hs-Tuple{PdagExtendability.HybridGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.is_adjacent_hs","text":"is_adjacent_hs(g::HybridGraph, u::Int64, v::Int64)::Bool\n\nCheck whether vertices u and v are adjacent in graph g.\n\nExamples\n\njulia> g = init_hs(3)\n...\njulia> is_adjacent_hs(g, 1, 2)\nfalse\njulia> insert_arc_hs!(g, 1, 2)\njulia> is_adjacent_hs(g, 1, 2)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.is_ps_hs-Tuple{PdagExtendability.HybridGraph, Int64}","page":"Extension Problem","title":"PdagExtendability.is_ps_hs","text":"is_ps_hs(g::HybridGraph, s::Int64)::Bool\n\nDetermine whether s is a potential sink in g.\n\nExamples\n\njulia> g = init_hs(3)\n...\njulia> is_ps_hs(g, 1)\ntrue\njulia> insert_arc_hs!(g, 1, 2)\njulia> is_ps_hs(g, 1)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.list_ps_hs-Tuple{PdagExtendability.HybridGraph}","page":"Extension Problem","title":"PdagExtendability.list_ps_hs","text":"list_ps_hs(g::HybridGraph)::Vector{Int64}\n\nList potential sinks in g.\n\nExamples\n\njulia> g = init_hs(3)\n...\njulia> list_ps_hs(g)\n3-element Array{Int64,1}:\n 1\n 2\n 3\njulia> insert_arc_hs!(g, 1, 2)\njulia> insert_edge_hs!(g, 2, 3)\njulia> list_ps_hs(g)\n1-element Array{Int64,1}:\n 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.pop_ps_hs!-Tuple{PdagExtendability.HybridGraph, Int64}","page":"Extension Problem","title":"PdagExtendability.pop_ps_hs!","text":"pop_ps_hs!(g::HybridGraph, s::Int64)::Vector{Int64}\n\nMark s as deleted and delete all edges (directed and undirected) incident to s. Return a list of neighbors of s that became potential sinks after the removal.\n\nExamples\n\njulia> g = init_hs(3)\n...\njulia> insert_arc_hs!(g, 1, 2)\njulia> insert_edge_hs!(g, 2, 3)\njulia> list_ps_hs(g)\n1-element Array{Int64,1}:\n 3\njulia> pop_ps_hs!(g, 3)\n1-element Array{Int64,1}:\n 2\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.print_graph_hs-2","page":"Extension Problem","title":"PdagExtendability.print_graph_hs","text":"print_graph_hs(g::HybridGraph, io::Core.IO = stdout)\n\nPrint the components of a HybridGraph g.\n\nExamples\n\njulia> g = init_hs(1)\n...\njulia> print_graph_hs(g)\nVertex 1:\n        Alpha   = 0     Beta    = 0\n        δ+(G1)  = 0     δ-(G1)  = 0     δ+(G2)  = 0     δ-(G2)  = 0\n        Adj(G1) =       Adj(G2) = \n        In(G1)  =       In(G2)  = \n        Out(G1) =       Out(G2) = \n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.remove_arc_hs!-Tuple{PdagExtendability.DirectedGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.remove_arc_hs!","text":"remove_arc_hs!(g::DirectedGraph, u::Int64, v::Int64)\n\nRemove an arc (a directed edge) from u to v from g.\n\nIs called internally and should not be called by hand! For removing arcs, use the function removearchs! directly on the HybridGraph datastructure instead.\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.remove_arc_hs!-Tuple{PdagExtendability.HybridGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.remove_arc_hs!","text":"remove_arc_hs!(g::HybridGraph, u::Int64, v::Int64)\n\nRemove an arc (a directed edge) from u to v from g.\n\nExamples\n\njulia> g = init_hs(3)\n...\njulia> insert_arc_hs!(g, 1, 2)\njulia> is_adjacent_hs(g, 1, 2)\ntrue\njulia> remove_arc_hs!(g, 1, 2)\njulia> is_adjacent_hs(g, 1, 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.remove_edge_hs!-Tuple{PdagExtendability.HybridGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.remove_edge_hs!","text":"remove_edge_hs!(g::HybridGraph, u::Int64, v::Int64)\n\nRemove an undirected edge between u and v from g.\n\nExamples\n\njulia> g = init_hs(3)\n...\njulia> insert_edge_hs!(g, 2, 3)\njulia> is_adjacent_hs(g, 2, 3)\ntrue\njulia> remove_edge_hs!(g, 2, 3)\njulia> is_adjacent_hs(g, 2, 3)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.update_alphabeta_hs!-Tuple{PdagExtendability.HybridGraph, Int64, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.update_alphabeta_hs!","text":"update_alphabeta_hs!(g::HybridGraph, u::Int64, v::Int64, val::Int64)\n\nUpdate values for alpha and beta in g. Either add to (positive value for val) or subtract from (negative value for val) alpha and beta.\n\nIs called internally whenever an edge (both directed and undirected) is inserted or removed. Do not call this function by hand.\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.extendgraph_hs-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph, PdagExtendability.HybridGraph}","page":"Extension Problem","title":"PdagExtendability.extendgraph_hs","text":"extendgraph_hs(g::SimpleDiGraph, hg::HybridGraph)::SimpleDiGraph\n\nCompute the extension of graph hg.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> hg = standardsetup_hs(g)\n...\njulia> extendgraph_hs(g, hg)\n{3, 2} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.fastpdag2dag_hs","page":"Extension Problem","title":"PdagExtendability.fastpdag2dag_hs","text":"fastpdag2dag_hs(g::SimpleDiGraph, optimize::Bool = false)::SimpleDiGraph\n\nConvert a partially directed acyclic graph (PDAG) into a fully directed acyclic graph (DAG). If this is not possible, an empty graph is returned.\n\nUndirected edges are represented as two directed edges.\n\nIf the parameter optimize is omitted or set to false, the algorithm runs in time O(Δm) with Δ being the maximum degree of g and m the number of edges in g. Setting optimize to true will yield an algorithm in time O(dm), where d is the degeneracy of the skeleton.\n\nReferences\n\nM. Wienöbst, M. Bannach, M. Liśkiewicz (2021). Extendability of Causal Graphical Models: Algorithms and Computational Complexity. 37th Conference on Uncertainty in Artificial Intelligence, 2021 (UAI 2021).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> dag = fastpdag2dag_hs(g)\n{3, 2} directed simple Int64 graph\njulia> collect(edges(dag))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\njulia> dag = fastpdag2dag_hs(g, true)\n{3, 2} directed simple Int64 graph\njulia> collect(edges(dag))\n2-element Array{LightGraphs.SimpleGraphs.SimpleEdge{Int64},1}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.optimizedsetup_hs-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.optimizedsetup_hs","text":"optimizedsetup_hs(g::SimpleDiGraph)::HybridGraph\n\nSet up the datastructure for the algorithm with time complexity O(dm).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> optimizedsetup_hs(g)\nHybridGraph(\n\tDirectedGraph(\n\t\tSet{Int64}[Set(), Set([3]), Set([2])],\n\t\t[0, 1, 1],\n\t\t[0, 1, 1],\n\t\tSet{Int64}[Set(), Set([3]), Set([2])],\n\t\tSet{Int64}[Set(), Set([3]), Set([2])]\n\t),\n\tDirectedGraph(\n\t\tSet{Int64}[Set([2]), Set([1]), Set()],\n\t\t[1, 0, 0],\n\t\t[0, 1, 0],\n\t\tSet{Int64}[Set(), Set([1]), Set()],\n\t\tSet{Int64}[Set([2]), Set(), Set()]\n\t),\n\t[0, 0, 0],\n\t[0, 0, 0]\n)\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.standardsetup_hs-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.standardsetup_hs","text":"standardsetup_hs(g::SimpleDiGraph)::HybridGraph\n\nSet up the datastructure for the algorithm with time complexity O(Δm).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> standardsetup_hs(g)\nHybridGraph(\n\tDirectedGraph(\n\t\tSet{Int64}[Set(), Set([3]), Set([2])],\n\t\t[0, 1, 1],\n\t\t[0, 1, 1],\n\t\tSet{Int64}[Set(), Set([3]), Set([2])],\n\t\tSet{Int64}[Set(), Set([3]), Set([2])]\n\t),\n\tDirectedGraph(\n\t\tSet{Int64}[Set([2]), Set([1]), Set()],\n\t\t[1, 0, 0],\n\t\t[0, 1, 0],\n\t\tSet{Int64}[Set(), Set([1]), Set()],\n\t\tSet{Int64}[Set([2]), Set(), Set()]\n\t),\n\t[0, 0, 0],\n\t[0, 0, 0]\n)\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.deg_struct_hs-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.deg_struct_hs","text":"deg_struct_hs(g::DtGraph)::Tuple{Vector{Int64}, Vector{Set{Int64}}}\n\nCompute the degree structure for the graph g. Return a tuple consisting of an array holding the degree for each vertex in g and an array where each index represents a degree (index 1 for degree 0, index 2 for degree 1, ..., index n for degree n-1) and holds a set of vertices which have that degree.\n\nFor example, if we have three vertices 1, 2, 3 with degree 1, 2, and 1, respectively, we obtain the following degree structure: ([1, 2, 1], [Set(), Set([1, 3]), Set([2])])\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> deg_struct_hs(setup_hs(g))\n([1, 2, 1], Set{Int64}[Set(), Set([3, 1]), Set([2])])\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.degeneracy_ordering_hs-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.degeneracy_ordering_hs","text":"degeneracy_ordering_hs(g::SimpleDiGraph)::Tuple{Vector{Int64}, Vector{Int64}}\n\nCompute a degeneracy ordering for the skeleton of the graph g. The second component of the tuple holds a mapping for each vertex of the ordering that maps the vertex to its index in the ordering.\n\nReferences\n\nDavid W. Matula, Leland L. Beck (1983). Smallest-last ordering and clustering and graph coloring algorithms. Journal of the ACM, 30(3):417–427.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> degeneracy_ordering_hs(g)\n([1, 2, 3], [1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.pop_min_deg_vertex_hs!-Tuple{Vector{Set{Int64}}}","page":"Extension Problem","title":"PdagExtendability.pop_min_deg_vertex_hs!","text":"pop_min_deg_vertex_hs!(degs::Vector{Set{Int64}})::Int64\n\nFind the vertex with minimum degree in the given degree structure. The vertex will be removed from the structure before returning it. In case there are multiple vertices with the same minimum degree, there is no specific order of choosing them, i.e., any of those vertices is returned.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> (_, degs) = deg_struct_hs(g)\n([1, 2, 1], Set{Int64}[Set(), Set([3, 1]), Set([2])])\njulia> pop_min_deg_vertex_hs!(degs)\n3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.update_deg_hs!-Tuple{Int64, Vector{Int64}, Vector{Set{Int64}}}","page":"Extension Problem","title":"PdagExtendability.update_deg_hs!","text":"update_deg_hs!(v::Int64, aux::Vector{Int64}, degs::Vector{Set{Int64}})\n\nUpdate the degree of a vertex after an adjacent vertex has been removed, i.e., reduce the degree by one and move it into the correct set in the degree structure.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> (aux, degs) = deg_struct_hs(g)\n([1, 2, 1], Set{Int64}[Set(), Set([3, 1]), Set([2])])\njulia> update_deg_hs!(3, aux, degs)\njulia> (aux, degs)\n([1, 2, 0], Set{Int64}[Set([3]), Set([1]), Set([2])])\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.countvstructs-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.countvstructs","text":"countvstructs(g::DtGraph)::UInt\n\nCount the numer of v-structures in the given graph g.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> countvstructs(setup_hs(g))\n1\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.pdag2mpdag2dag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.pdag2mpdag2dag","text":"pdag2mpdag2dag(g::SimpleDiGraph)::SimpleDiGraph\n\nConvert a PDAG into a DAG. First, Meek's rules are applied exhaustively to the input graph, then it is checked whether cycles or new v-structures were formed (if so, the input is not extendable) and lastly, the resulting MPDAG is converted into a DAG in linear time.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> collect(edges(pdag2mpdag2dag(g)))\n2-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#Algorithms-for-Specific-Types-of-Input-Graphs","page":"Extension Problem","title":"Algorithms for Specific Types of Input Graphs","text":"","category":"section"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"The following algorithms are implemented using HashSets internally as well, but they work only for specific types of input graphs.","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"dir2dag - An algorithm with worst-case time complexity O(V+E) that works only for fully directed input graphs.\nundir2dag - An algorithm with worst-case time complexity O(V+E) that works only for fully undirected input graphs.\nmpdag2dag - An algorithm with worst-case time complexity O(V+E) that works only for maximally oriented partially directed acyclic graphs (MPDAGs).","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"Modules = [PdagExtendability]\nPages = [\n\t\"extendability/implementation_hs/depth_first_search_hs.jl\",\n\t\"extendability/implementation_hs/maximum_cardinality_search_hs.jl\",\n\t\"extendability/implementation_mpdag/connected_components.jl\",\n\t\"extendability/implementation_mpdag/meek_rules.jl\",\n\t\"extendability/implementation_mpdag/new_algo_mpdag.jl\"\n]","category":"page"},{"location":"extendability/#PdagExtendability.dir2dag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.dir2dag","text":"dir2dag(g::SimpleDiGraph)::SimpleDiGraph\n\nConvert a directed graph into a fully directed acyclic graph (DAG). If this is not possible, an empty graph is returned.\n\nNote that this function only works for fully directed input graphs as it simply checks acyclicity of the input graph.\n\nImportant: The input must not contain two edges between the same two nodes (i.e., if an edge u->v exists, v->u is forbidden) because the internal data structure treats such edges as undirected edges.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 1, 3)\ntrue\njulia> collect(edges(dir2dag(g)))\n2-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 1 => 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.iscyclic!-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.iscyclic!","text":"iscyclic!(g::DtGraph)::Bool\n\nChecks whether g is cyclic by computing a topological sorting using Kahn's algorithm. Note that g must be fully directed (undirected edges are forbidden).\n\nImportant: The input must not contain two edges between the same two nodes (i.e., if an edge u->v exists, v->u is forbidden) because the internal data structure treats such edges as undirected edges.\n\nReferences\n\nKahn, Arthur B. (1962). Topological sorting of large networks. Communications of the ACM, 5\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 1, 3)\ntrue\njulia> iscyclic!(setup_hs(g))\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.ispeo-Tuple{DtGraph, Tuple{Vector{Int64}, Vector{Int64}}}","page":"Extension Problem","title":"PdagExtendability.ispeo","text":"ispeo(g::DtGraph, ordering::Tuple{Vector{Int64}, Vector{Int64}})::Bool\n\nCheck whether ordering is a perfect elimination order. That is, for each vertex v, v and all neighbors coming after v form a clique.\n\nExamples\n\njulia> g = SimpleGraph(3)\n{3, 0} undirected simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 1, 3)\ntrue\njulia> add_edge!(g, 2, 3)\njulia> dt = setup_hs(graph2digraph(g))\n...\njulia> ispeo(dt, mcs(dt))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.mcs-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.mcs","text":"mcs(g::DtGraph)::Tuple{Vector{Int64}, Vector{Int64}}\n\nCompute a vertex ordering using maximum cardinality search.\n\nReferences\n\nTarjan, Robert E.; Yannakakis, Mihalis (1984). Simple Linear-Time Algorithms to Test Chordality of Graphs, Test Acyclicity of Hypergraphs, and Selectively Reduce Acyclic Hypergraphs. SIAM Journal on Computing, 13(3), 566–579.\n\nExamples\n\njulia> g = SimpleGraph(3)\n{3, 0} undirected simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 1, 3)\ntrue\njulia> add_edge!(g, 2, 3)\njulia> dt = setup_hs(graph2digraph(g))\n...\njulia> mcs(dt)\n([3, 1, 2], [2, 3, 1])\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.undir2dag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.undir2dag","text":"undir2dag(g::SimpleDiGraph)::SimpleDiGraph\n\nConvert an undirected graph into a fully directed acyclic graph (DAG). If this is not possible, an empty graph is returned.\n\nExamples\n\njulia> g = SimpleGraph(3)\n{3, 0} undirected simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 1, 3)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> collect(edges(undir2dag(graph2digraph(g))))\n3-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 2 => 1\n Edge 2 => 3\n Edge 3 => 1\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.buckets-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.buckets","text":"buckets(g::DtGraph)::Vector{Set{Int64}}\n\nCompute all buckets, i.e., maximum undirected subcomponents, of g.\n\nReferences\n\nM. Wienöbst, M. Bannach, M. Liśkiewicz (2021). Extendability of Causal Graphical Models: Algorithms and Computational Complexity. 37th Conference on Uncertainty in Artificial Intelligence, 2021 (UAI 2021).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> buckets(setup_hs(g))\nSet{Int64}[]\njulia> add_edge!(g, 3, 2)\ntrue\njulia> buckets(setup_hs(g))\n1-element Vector{Set{Int64}}:\n Set([2, 3])\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.dfs!-Tuple{DtGraph, Int64, BitArray}","page":"Extension Problem","title":"PdagExtendability.dfs!","text":"dfs!(g::DtGraph, u::Int64, visited::BitArray)::Set{Int64}\n\nStart a depth first search at vertex u in graph g and visit only previously unvisited vertices. visited specifies for each vertex whether it was visited before or not and is updated accordingly. The result is a set of vertices reachable from u via undirected edges only.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> dfs!(setup_hs(g), 1, falses(3))\nSet{Int64} with 1 element:\n  1\njulia> dfs!(setup_hs(g), 2, falses(3))\nSet{Int64} with 2 elements:\n  2\n  3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.directedge!-Tuple{DtGraph, Int64, Int64}","page":"Extension Problem","title":"PdagExtendability.directedge!","text":"directedge!(g::DtGraph, u::Int64, v::Int64)\n\nDirect an undirected edge u-v in g from u to v (u->v).\n\nExamples\n\njulia> g = SimpleDiGraph(2)\n{2, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 1)\ntrue\njulia> dtgr = setup_hs(g)\nDtGraph(\n\t2,\n\tSet([2, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set()],\n\tSet{Int64}[Set(), Set()],\n\tSet{Int64}[Set([2]), Set([1])]\n)\njulia> directedge!(dtgr, 1, 2)\njulia> dtgr\nDtGraph(\n\t2,\n\tSet([2, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1])],\n\tSet{Int64}[Set([2]), Set()],\n\tSet{Int64}[Set(), Set()]\n)\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.dtgraph2digraph-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.dtgraph2digraph","text":"Examples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> g == dtgraph2digraph(setup_hs(g))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.hascycledfs!-Tuple{DtGraph, Vector{Int64}, Vector{UInt8}}","page":"Extension Problem","title":"PdagExtendability.hascycledfs!","text":"hascycledfs!(g::DtGraph, stack::Vector{Int64}, visited::Vector{UInt8})::Bool\n\nCalled by hasdircycle to perform a depth first search checking for cycles in a graph.\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.hasdircycle-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.hasdircycle","text":"hasdircycle(g::DtGraph)::Bool\n\nCheck whether the graph g contains a directed cycle.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 1)\ntrue\njulia> hasdircycle(setup_hs(g))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.ismpdag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.ismpdag","text":"ismpdag(g::SimpleDiGraph)::Bool\n\nCheck whether a given graph g is an MPDAG.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 1)\ntrue\njulia> ismpdag(g)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.pdag2mpdag-Tuple{Any}","page":"Extension Problem","title":"PdagExtendability.pdag2mpdag","text":"pdag2mpdag(g; nocopy = false)::DtGraph\n\nApply the four Meek Rules to the input PDAG in order to obtain an MPDAG. The input must either be of type SimpleDiGraph or DtGraph. In case the input has type DtGraph, the paramter nocopy can be set to true in order to manipulate it directly instead of creating a copy.\n\nReferences\n\nMeek, C. (1995). Causal Inference and Causal Explanation with Background Knowledge. In Proceedings of the Eleventh Conference on Uncertainty in Artificial Intelligence, UAI’95.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> collect(edges(dtgraph2digraph(pdag2mpdag(g))))\n2-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.amo-Tuple{DtGraph}","page":"Extension Problem","title":"PdagExtendability.amo","text":"amo(g::DtGraph)::Tuple{Vector{Int64}, Vector{Int64}}\n\nCompute an acyclic moral orientation (AMO) for a bucket in linear time. If the input graph does not admit an AMO, the result will not be an AMO but an arbitrary ordering. The result can be checked via isamo.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> amo(setup_hs(g))\n([1, 2, 3], [1, 2, 3])\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.isamo-Tuple{DtGraph, Tuple{Vector{Int64}, Vector{Int64}}}","page":"Extension Problem","title":"PdagExtendability.isamo","text":"isamo(g::DtGraph, ordering::Tuple{Vector{Int64}, Vector{Int64}})::Bool\n\nCheck whether a given ordering is an acyclic moral orientation for a bucket.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> dtgraph = setup_hs(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set([2])],\n\tSet{Int64}[Set([2]), Set([3]), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> isamo(dtgraph, amo(dtgraph))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.mpdag2dag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.mpdag2dag","text":"mpdag2dag(g::SimpleDiGraph)::SimpleDiGraph\n\nConvert a given MPDAG to a consistent DAG extension. Only works for MPDAGs.\n\nReferences\n\nM. Wienöbst, M. Bannach, M. Liśkiewicz (2021). Extendability of Causal Graphical Models: Algorithms and Computational Complexity. 37th Conference on Uncertainty in Artificial Intelligence, 2021 (UAI 2021).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> collect(edges(mpdag2dag(g)))\n2-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 3\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.subgraph-Tuple{DtGraph, Set{Int64}, Dict}","page":"Extension Problem","title":"PdagExtendability.subgraph","text":"subgraph(g::DtGraph, bucket::Set{Int64}, m::Dict)::DtGraph\n\nCompute the subgraph induces by the vertices in bucket. m is a mapping for vertices which is necessary if the vertices in bucket are not labelled from 1 to length(bucket). It has to map each vertex in bucket to a number between 1 and length(bucket).\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> s = subgraph(setup_hs(g), Set([1, 2]), Dict(1 => 1, 2 => 2))\nDtGraph(\n\t2,\n\tSet([2, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1])],\n\tSet{Int64}[Set([2]), Set()],\n\tSet{Int64}[Set(), Set()]\n)\njulia> collect(edges(dtgraph2digraph(s)))\n1-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n\n\n\n\n\n","category":"method"},{"location":"extendability/#Debugging","page":"Extension Problem","title":"Debugging","text":"","category":"section"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"In practice, the algorithm pdag2dag_hs may sometimes be faster than fastpdag2dag_hs, although it has a worse time complexity. Thus, one might be interested to find out how many iterations were actually needed by the algorithm pdag2dag_hs to compute the result.","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"The debug version pdag2dag_debug_hs logs the average number of iterations needed to find a potential sink in the input graph. Note that a potential sink is searched V-times, i.e., the total number of iterations can be approximated by multiplying the outputted average with V.","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"pdag2dag_debug_lg does the same for the implementation using the LightGraphs library internally.","category":"page"},{"location":"extendability/","page":"Extension Problem","title":"Extension Problem","text":"Modules = [PdagExtendability]\nPages = [\n\t\"extendability/implementation_hs/dor_tarsi_debug_hs.jl\",\n\t\"extendability/implementation_lg/dor_tarsi_debug_lg.jl\"\n]","category":"page"},{"location":"extendability/#PdagExtendability.is_sink_debug_hs-Tuple{DtGraph, Int64}","page":"Extension Problem","title":"PdagExtendability.is_sink_debug_hs","text":"is_sink_debug_hs(graph::DtGraph, x::Int64)::Tuple{Bool, Int64}\n\nDebug version of is_sink_hs. The debug version counts the number of iterations needed to check whether x is a sink. \n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.pdag2dag_debug_hs","page":"Extension Problem","title":"PdagExtendability.pdag2dag_debug_hs","text":"pdag2dag_debug_hs(g::SimpleDiGraph, useheuristic::Bool = false)::SimpleDiGraph\n\nDebug version of pdag2dag_hs. The debug version logs the average number of iterations needed to find a sink.\n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.sink_debug_hs","page":"Extension Problem","title":"PdagExtendability.sink_debug_hs","text":"sink_debug_hs(graph::DtGraph, useheuristic::Bool = false)::Tuple{Int64, Int64, Vector{Int64}}\n\nDebug version of sink_hs. The debug version counts the number of iterations needed to find a sink and computes the average number of iterations needed in the whole algorithm. \n\n\n\n\n\n","category":"function"},{"location":"extendability/#PdagExtendability.pdag2dag_debug_lg-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.pdag2dag_debug_lg","text":"pdag2dag_debug_lg(g::SimpleDiGraph)::SimpleDiGraph\n\nDebug version of pdag2dag_lg.\n\n\n\n\n\n","category":"method"},{"location":"extendability/#PdagExtendability.sink_debug_lg-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Extension Problem","title":"PdagExtendability.sink_debug_lg","text":"sink_debug_lg(g::SimpleDiGraph)::Tuple{Int64, Int64}\n\nDebug version of sink_lg.\n\n\n\n\n\n","category":"method"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The first step to use this benchmarking framework is to download the source repository. The repository contains all benchmarks in addition to the source code itself. It can be downloaded using Git:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"git clone git@github.com:Malte311/PdagExtendability.git","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The Docker container can then be started via ./run.sh. Using Docker, you don't have to install the dependencies on your machine (in fact, you don't even need Julia to be installed). After running ./run.sh, you can directly interact with Julia in the terminal provided by Docker.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to run the benchmarks, simply run the following command.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia run.jl \"../configs/config-1.json\"","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"You can adapt the configuration file config.json in order to customize the setup. These are the configuration options which are provided:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"algorithm: An array containing the function calls of the algorithms which should be run (i.e., parenthesis and additional parameters must be provided). Available algorithms for the extension problem are pdag2dag_hs, altpdag2dag_hs, pdag2dag_lg, fastpdag2dag_hs, fastpdag2dag_lg, and pdag2mpdag2dag. For fully undirected graphs undir2dag is an option as well, for fully directed graphs the algorithm dir2dag can be used as well, and for maximally oriented partially directed acyclic graphs (i.e., graphs from the subdirectory benchmarks/mpdirected) the algorithm mpdag2dag might be utilized as well.\nalgorithm_log_id (optional): An id to identify a specific run. For example, if you run the same algorithm twice, both results are named the same. In order to prevent this, you can add an id for each run. The id can be an arbitrary string.\nbenchmarkdir: The path to the directory which contains the benchmarks which should be run. Note that all subdirectories are evaluated as well.\ncreate_csv: Boolean value to specify whether a .csv file of the run should be created. The file contains one row per benchmark. Each row contains the name of the algorithm, the name of the input file, and the measured time for that instance.\nenumerate: Boolean value to specify whether the algorithms solve the enumeration problem (true) or the extension problem (false).\nlogdir: The path to the directory in which logs should be written.\nlogfile: The name of the logfile.\nlogtofile: Boolean value to specify whether logs should be written to the logfile (true) or to stdout (false).\nnum_evals: The number of evaluations per sample.\nnum_samples: The number of samples to take.\nonly_undirected: Boolean value to specify whether the input graphs contain only undirected edges (true) or not (false), i.e., if undirected edges are not encoded via two directed edges in the input file. For the benchmarks/undirected directory, this should be set to true. For all of the other directories (e.g., benchmarks/directed and benchmarks/pdirected), it should be set to false.\nuse_median: Boolean value to specify whether to use the median of the measurements. If set to false, the mean will be used instead.\nvisualize: Boolean value to specify whether the input graph and the output graph should be plotted and saved to a .svg file.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"It is also possible to run multiple trials simultaneously using different configuration files for each trial. An exemplary configuration file could look like this:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"{\n\t\"algorithm\": [\n\t\t\"pdag2dag_hs(false)\",\n\t\t\"pdag2dag_hs(true)\",\n\t\t\"fastpdag2dag_hs(false)\",\n\t\t\"fastpdag2dag_hs(true)\"\n\t],\n\t\"algorithm_log_id\": \"\",\n\t\"benchmarkdir\": \"../benchmarks/pdirected/sparse/n=1024/\",\n\t\"create_csv\": false,\n\t\"enumerate\": false,\n\t\"logdir\": \"../logs/\",\n\t\"logfile\": \"log-1.txt\",\n\t\"logtofile\": false,\n\t\"num_evals\": 1,\n\t\"num_samples\": 5,\n\t\"only_undirected\": false,\n\t\"use_median\": true,\n\t\"visualize\": false\n}","category":"page"},{"location":"getting_started/#Generating-Your-Own-Benchmarks","page":"Getting Started","title":"Generating Your Own Benchmarks","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"In order to run the algorithms on other graphs than the provided benchmarks, you can generate your own graphs. There are plenty of functions for generating graphs which can be found under the Utilities section.","category":"page"},{"location":"enumeration/#enumeration_header","page":"Enumeration Problem","title":"Enumeration Problem","text":"","category":"section"},{"location":"enumeration/","page":"Enumeration Problem","title":"Enumeration Problem","text":"Below, there are algorithms listed that solve the enumeration problem. That is, given a partially directed graph G, compute all consistent DAG extensions of G.","category":"page"},{"location":"enumeration/","page":"Enumeration Problem","title":"Enumeration Problem","text":"Currently, the following algorithms are available:","category":"page"},{"location":"enumeration/","page":"Enumeration Problem","title":"Enumeration Problem","text":"enumerate_v1 - An algorithm with worst-case time complexity O(2^E Delta E^3).\nenumerate_v2 - An algorithm with worst-case time complexity O(2^E Delta E^3).","category":"page"},{"location":"enumeration/","page":"Enumeration Problem","title":"Enumeration Problem","text":"Both algorithms enumerate_v1 and enumerate_v2 do not differ very much and use a rather naive approach to compute a result.","category":"page"},{"location":"enumeration/","page":"Enumeration Problem","title":"Enumeration Problem","text":"Modules = [PdagExtendability]\nPages = [\n\t\"enumeration/enumerate_v1.jl\",\n\t\"enumeration/enumerate_v2.jl\"\n]","category":"page"},{"location":"enumeration/#PdagExtendability.enumerate_v1-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Enumeration Problem","title":"PdagExtendability.enumerate_v1","text":"enumerate_v1(g::SimpleDiGraph)::Vector{DtGraph}\n\nCompute all consistent extensions of the input graph g by first generating all fully directed graphs with the same edge directions as in g and then removing the ones that are either cyclic or do not have the same set of v-structures as g.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> enumerate_v1(g)\n1-element Vector{DtGraph}:\n DtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set([2])],\n\tSet{Int64}[Set([2]), Set([3]), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n )\n\n\n\n\n\n","category":"method"},{"location":"enumeration/#PdagExtendability.extensions_rec!-Tuple{DtGraph, UInt64, Vector{T} where T}","page":"Enumeration Problem","title":"PdagExtendability.extensions_rec!","text":"extensions_rec!(g::DtGraph, numvstr::UInt, undiredges::Vector)::Vector\n\nCompute all extensions of g recursively by generating all possible directions and filter out those which are either cyclic or not consistent.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> mpdag = pdag2mpdag(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set([2])],\n\tSet{Int64}[Set([2]), Set([3]), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> extensions_rec!(mpdag, countvstructs(mpdag), [(2, 3)])\n1-element Vector{Any}:\n DtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set([2])],\n\tSet{Int64}[Set([2]), Set([3]), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n )\n\n\n\n\n\n","category":"method"},{"location":"enumeration/#PdagExtendability.enumerate_v2-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Enumeration Problem","title":"PdagExtendability.enumerate_v2","text":"enumerate_v2(g::SimpleDiGraph)::Vector{DtGraph}\n\nCompute all consistent extensions of the input graph g by directing a random edge in both directions, close the result under the four Meek rules, and recursing.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> enumerate_v2(g)\n1-element Vector{DtGraph}:\n DtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set([2])],\n\tSet{Int64}[Set([2]), Set([3]), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n )\n\n\n\n\n\n","category":"method"},{"location":"enumeration/#PdagExtendability.extsmeek_rec!-Tuple{DtGraph, UInt64, Vector{T} where T}","page":"Enumeration Problem","title":"PdagExtendability.extsmeek_rec!","text":"extsmeek_rec!(g::DtGraph, numvstr::UInt, undiredges::Vector)::Vector\n\nCompute all extensions of g recursively by generating all possible directions and applying Meek's rules every time an edges was directed on the resulting graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> mpdag = pdag2mpdag(g)\nDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set([2])],\n\tSet{Int64}[Set([2]), Set([3]), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n)\njulia> extsmeek_rec!(mpdag, countvstructs(mpdag), [(2, 3)])\n1-element Vector{Any}:\n\tDtGraph(\n\t3,\n\tSet([2, 3, 1]),\n\tSet{Int64}[],\n\tSet{Int64}[Set(), Set([1]), Set([2])],\n\tSet{Int64}[Set([2]), Set([3]), Set()],\n\tSet{Int64}[Set(), Set(), Set()]\n\t)\n\n\n\n\n\n","category":"method"},{"location":"#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"A benchmarking framework for the extendability of (causal) graphs. The benchmarking framework contains efficient algorithms for extending (causal) graphs and more than 1000 exemplary input graph instances.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"More precisely, algorithms solving the following two problems are provided:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Given any partially directed graph G, compute a consistent DAG extension for G if G admits such an extension, otherwise return a negative answer (Extension Problem).\nGiven any partially directed graph G, compute the set of all consistent DAG extensions for G (Enumeration Problem).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"We denote that the number of vertices in the input graph as V and the number of edges in the input graph as E. The maximum degree in the input graph is denoted as Delta.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"note: Note\nPlease note that this framework is part of a master's thesis and thus is not professionally maintained.","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Fast algorithms for the extension problem and for the enumeration problem.\nAutomatically run benchmarks and create time measurements in .csv format.\nFull Docker support. Julia does not even have to be installed on your system.\nAutomatically build and deploy via TravisCI.","category":"page"},{"location":"#Documentation-Outline","page":"Overview","title":"Documentation Outline","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Depth = 2","category":"page"},{"location":"#Index","page":"Overview","title":"Index","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"","category":"page"},{"location":"utils/#utilities_header","page":"Utilities","title":"Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"This section contains the documentation for the utilities. The functions listed below are mostly used dealing with graphs and for generating input graph instances (randomly or specific types of graphs).","category":"page"},{"location":"utils/#Graph-Utilities","page":"Utilities","title":"Graph Utilities","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"These utilities are for dealing with graphs in general (reading graphs from a file, plotting graphs, converting graphs, etc.).","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [PdagExtendability]\nPages = [\n\t\"utils/logparser.jl\",\n\t\"utils/plotting.jl\",\n\t\"utils/readinput.jl\",\n\t\"utils/utils.jl\"\n]","category":"page"},{"location":"utils/#PdagExtendability.algo2label-Tuple{String}","page":"Utilities","title":"PdagExtendability.algo2label","text":"algo2label(algo::String)::String\n\nMap the function name of the used algorithm to a label for the plot.\n\nExamples\n\njulia> algo2label(\"pdag2dag_hs()-1\")\nDor Tarsi HS - Standard - 1\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.dict_to_csv-Tuple{Dict}","page":"Utilities","title":"PdagExtendability.dict_to_csv","text":"dict_to_csv(dict::Dict, use_median::Bool = true)::String\n\nConvert a dictionary of time measurements into a csv-formatted string. The parameter use_median indicates whether the median or mean should be used: If set to true (or ommitted), the median will be used, otherwise the mean.\n\nIt is possible to set the file parameter in order to save the csv-formatted string in that given file.\n\nExamples\n\njulia> dict = get_times_dict(\"../logs/log.txt\")\nDict{String,Dict{Any,Any}} with 1 entry:\n  \"pdag2dag_lg()-1\" => Dict{Any,Any}(\"example.txt\"=>Dict(\"median\"=>2426.5,\"mean\"=>2594.65))\njulia> dict_to_csv(dict)\n  \"Algorithm;Instance;Time\npdag2dag_lg()-1;example.txt;2426.5\n\"\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.get_times_dict-Tuple{String}","page":"Utilities","title":"PdagExtendability.get_times_dict","text":"get_times_dict(file::String)::Dict\n\nConvert a logfile to a dictionary containing the times. The dictionary has the following structure: { \t\"algorithm\": { \t\t\"input1\": { \t\t\t\"median\": 1.124, \t\t\t\"mean\": 1.312 \t\t}, \t\t\"input2\": ... \t} }\n\nExamples\n\njulia> get_times_dict(\"../logs/log.txt\")\nDict{String,Dict{Any,Any}} with 1 entry:\n  \"pdag2dag_lg()-1\" => Dict{Any,Any}(\"example.txt\"=>Dict(\"median\"=>2426.5,\"mean\"=>2594.65))\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.print_dict","page":"Utilities","title":"PdagExtendability.print_dict","text":"print_dict(dict::Dict, io::Core.IO = stdout)\n\nPrint the contents of a dictionary as a formatted JSON string with readable indentation.\n\nExamples\n\njulia> dict = get_times_dict(\"../logs/log.txt\")\nDict{String,Dict{Any,Any}} with 1 entry:\n  \"pdag2dag_lg()\" => Dict{Any,Any}(\"example.txt\"=>Dict(\"median\"=>2426.5,\"mean\"=>2594.65))\njulia> julia> print_dict(dict)\n{\n    \"pdag2dag_lg()\": {\n        \"example.txt\": {\n            \"median\": 2426.5,\n            \"mean\": 2594.646\n        }\n    }\n}\n\n\n\n\n\n","category":"function"},{"location":"utils/#PdagExtendability.plotsvg-Tuple{Any, String}","page":"Utilities","title":"PdagExtendability.plotsvg","text":"plotsvg(g, file::String)\n\nDraw a graph and save it in a .svg file.\n\nExamples\n\njulia> g = SimpleDiGraph(2)\n{2, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> plotsvg(g, \"plot.svg\")\nfalse\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.readinputgraph","page":"Utilities","title":"PdagExtendability.readinputgraph","text":"readinputgraph(file::String, only_undir::Bool = false)::SimpleDiGraph\n\nRead a graph from a file and return a SimpleDiGraph. The file must be formatted as follows. The first line contains the number of vertices and the number of edges, separated by a space. One empty line follows. Afterwards, there is one line for each edge. Each line representing an edge has a startvertex and an endvertex, separated by a space. Undirected edges are represented by two directed edges.\n\nThe parameter only_undir can be set to true to indicate that the input graph contains only undirected edges. This allows the input file to contain only one edge for each undirected edge.\n\nExamples\n\njulia> g = readinputgraph(\"../benchmarks/example.txt\")\n{3, 3} directed simple Int64 graph\n\n\n\n\n\n","category":"function"},{"location":"utils/#PdagExtendability.graph2digraph-Tuple{LightGraphs.SimpleGraphs.SimpleGraph}","page":"Utilities","title":"PdagExtendability.graph2digraph","text":"graph2digraph(g::SimpleGraph)::SimpleDiGraph\n\nConvert an undirected graph (SimpleGraph) into a directed graph (SimpleDiGraph).\n\nExamples\n\njulia> g = SimpleGraph(3)\n{3, 0} undirected simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> collect(edges(graph2digraph(g)))\n2-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 1\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.graph2str-Tuple{Any}","page":"Utilities","title":"PdagExtendability.graph2str","text":"graph2str(g; is_only_undir::Bool = false)::String\n\nConvert a graph g to the corresponding string representation. Set is_only_undir to false if the graph contains directed edges.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> graph2str(g)\n\"3 0\n\"\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.is_consistent_extension-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph, LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Utilities","title":"PdagExtendability.is_consistent_extension","text":"is_consistent_extension(g1::SimpleDiGraph, g2::SimpleDiGraph)::Bool\n\nCheck whether g1 is a consistent extension of g2.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> e = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(e, 1, 2)\ntrue\njulia> add_edge!(e, 2, 3)\ntrue\njulia> is_consistent_extension(e, g)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.isdag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Utilities","title":"PdagExtendability.isdag","text":"isdag(g::SimpleDiGraph)::Bool\n\nCheck whether g is a directed acyclic graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> isdag(g)\ntrue\njulia> add_edge!(g, 3, 1)\ntrue\njulia> isdag(g)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.nanosec2millisec-Tuple{Float64}","page":"Utilities","title":"PdagExtendability.nanosec2millisec","text":"nanosec2sec(time::Float64)::Float64\n\nConvert a number in nanoseconds to milliseconds.\n\nExamples\n\njulia> nanosec2millisec(1000000.0)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.save2file-Tuple{Any, String}","page":"Utilities","title":"PdagExtendability.save2file","text":"save2file(g, file::String; is_only_undir::Bool = true)\n\nSave a graph g to a given file. Set is_only_undir to false if the graph contains directed edges.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> save2file(g, \"../benchmarks/dummy/graph.txt\")\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.skeleton-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Utilities","title":"PdagExtendability.skeleton","text":"skeleton(g::SimpleDiGraph)::Vector{Tuple{Int64, Int64}}\n\nCompute the skeleton of g. Edges are represented as tuples (u, v) where the smaller number is always first.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> skeleton(g)\n2-element Vector{Tuple{Int64, Int64}}:\n (1, 2)\n (2, 3)\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.vstructures-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph}","page":"Utilities","title":"PdagExtendability.vstructures","text":"vstructures(g::SimpleDiGraph)::Vector{Tuple{Int64, Int64, Int64}}\n\nCompute all v-structures of graph g. The v-structures of form u -> v <- w are represented as tuples (x, v, y) where x is always the minimum of u and w and y is the maximum of u and w. The list of v-structures which is returned is sorted first by x, then by v and last by y.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> vstructures(g)\n1-element Vector{Tuple{Int64, Int64, Int64}}:\n (1, 2, 3)\n\n\n\n\n\n","category":"method"},{"location":"utils/#utilities_graphgeneration_header","page":"Utilities","title":"Graph Generators","text":"","category":"section"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"In order to generate even more input graph instances, there are different graph generation approaches available. These graph generation approaches allow for an easy enlargement of the dataset of input graph instances.","category":"page"},{"location":"utils/","page":"Utilities","title":"Utilities","text":"Modules = [PdagExtendability]\nPages = [\n\t\"utils/dag_generator.jl\",\n\t\"utils/graph_generator.jl\",\n\t\"utils/pdag_generator.jl\",\n]","category":"page"},{"location":"utils/#PdagExtendability.random_dag-NTuple{5, Any}","page":"Utilities","title":"PdagExtendability.random_dag","text":"random_dag(min_r, max_r, min_v_per_r, max_v_per_r, prob)::SimpleDiGraph\n\nCreate a random DAG with the following properties: min_r is the minimum number of ranks for the DAG and max_r the maximum number of ranks. min_v_per_r indicates the minimum number of vertices per rank and max_v_per_r the maximum number of vertices per rank. prob is the probability of having an edge between two vertices.\n\nReferences\n\nhttps://stackoverflow.com/questions/12790337/generating-a-random-dag\n\nExamples\n\njulia> random_dag(3, 5, 3, 5, 0.2)\n{15, 19} directed simple Int64 graph\njulia> random_dag(3, 5, 3, 5, 0.2)\n{12, 12} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.random_dag_v2-Tuple{Int64, Int64}","page":"Utilities","title":"PdagExtendability.random_dag_v2","text":"random_dag_v2(n::Int64, m::Int64)::SimpleDiGraph\n\nCreate a random DAG with n vertices and m edges.\n\nExamples\n\njulia> random_dag_v2(10, 40)\n{10, 40} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.barbellgraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.barbellgraph","text":"barbellgraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a barbell graph with n vertices.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> barbellgraph(6)\n{6, 7} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.bintreegraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.bintreegraph","text":"bintreegraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a binary tree with n vertices.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> bintreegraph(7)\n{7, 6} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.centipedegraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.centipedegraph","text":"centipedegraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a centipede graph with n vertices. Note that n has to be equal.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> centipedegraph(8)\n{8, 7} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.cliquegraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.cliquegraph","text":"cliquegraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a clique graph with n vertices. The graph contains a clique of size n/2, where each vertex of that clique has one additional neighbor which is not connected to any other vertex. Note that n has to be equal.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> cliquegraph(8)\n{8, 10} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.completegraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.completegraph","text":"completegraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a complete graph with n vertices.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> completegraph(4)\n{4, 6} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.cyclegraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.cyclegraph","text":"cyclegraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a cycle with n vertices. Note that n has to be greater or equal to 3.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> cyclegraph(8)\n{8, 8} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.doublestargraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.doublestargraph","text":"doublestargraph(n::Int64; filepath = \"\")::SimpleGraph\n\nCreate a graph with n vertices, consisting of two connected stars.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> doublestargraph(8)\n{8, 7} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.extbarbellgraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.extbarbellgraph","text":"extbarbellgraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate an extended barbell graph with n vertices. That is, two cliques connected by a path. The cliques and the path are of size n/3 each.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> extbarbellgraph(8)\n{8, 7} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.friendshipgraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.friendshipgraph","text":"friendshipgraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a friendship graph with n vertices. Note that n has to be odd.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> friendshipgraph(7)\n{7, 9} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.graph2pdag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph, Float64}","page":"Utilities","title":"PdagExtendability.graph2pdag","text":"graph2pdag(g::SimpleDiGraph, prob::Float64)::SimpleDiGraph\n\nConvert an undirected graph (encoded as a SimpleDiGraph) into a partially directed graph.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 1)\ntrue\njulia> add_edge!(g, 1, 3)\ntrue\njulia> add_edge!(g, 3, 1)\ntrue\njulia> collect(edges(graph2pdag(g, 0.5)))\n3-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 2 => 1\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.pathgraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.pathgraph","text":"pathgraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a path with n vertices.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> pathgraph(10)\n{10, 9} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.stargraph-Tuple{Int64}","page":"Utilities","title":"PdagExtendability.stargraph","text":"stargraph(n::Int64; filepath::String = \"\")::SimpleGraph\n\nCreate a star graph with n vertices.\n\nIf a filepath is provided, the graph will also be written to that file.\n\nExamples\n\njulia> stargraph(11)\n{11, 10} undirected simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.erdos_renyi_pdag-Tuple{Int64, Float64, Float64}","page":"Utilities","title":"PdagExtendability.erdos_renyi_pdag","text":"erdos_renyi_pdag(n::Int64, p1::Float64, p2::Float64; seed = 123)::SimpleDiGraph\n\nCreate a partially directed graph using the Erdős–Rényi model. The graph has n vertices with a probability p1 for having an edge between two vertices. p2 is the probablity for an edge to be directed.\n\nExamples\n\njulia> erdos_renyi_pdag(10, 0.2, 0.5)\n{10, 12} directed simple Int64 graph\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.random_pdag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph, Float64}","page":"Utilities","title":"PdagExtendability.random_pdag","text":"random_pdag(g::SimpleDiGraph, p::Float64)::g::SimpleDiGraph\n\nGenerates a partially directed graph by directing a given percentage of edges in a given undirected graph. Takes as input a fully undirected graph, encoded as a SimpleDiGraph. The generated PDAG will be extendable if the input is extendable.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 1)\ntrue\njulia> add_edge!(g, 1, 3)\ntrue\njulia> add_edge!(g, 3, 1)\njulia> collect(edges(random_pdag(g, 0.5)))\n3-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 1 => 3\n Edge 3 => 1\n\n\n\n\n\n","category":"method"},{"location":"utils/#PdagExtendability.random_pdag-Tuple{LightGraphs.SimpleGraphs.SimpleDiGraph, Int64}","page":"Utilities","title":"PdagExtendability.random_pdag","text":"random_pdag(g::SimpleDiGraph, m::Int64)::SimpleDiGraph\n\nGenerates a partially directed graph by keeping m undirected edges in a given undirected graph g; all other edges are being directed. Takes as input a fully undirected graph, encoded as a SimpleDiGraph. The generated PDAG will be extendable if the input is extendable.\n\nExamples\n\njulia> g = SimpleDiGraph(3)\n{3, 0} directed simple Int64 graph\njulia> add_edge!(g, 1, 2)\ntrue\njulia> add_edge!(g, 2, 1)\ntrue\njulia> add_edge!(g, 2, 3)\ntrue\njulia> add_edge!(g, 3, 2)\ntrue\njulia> collect(edges(random_pdag(g, 1)))\n3-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 1\n Edge 2 => 3\njulia> collect(edges(random_pdag(g, 1)))\n3-element Vector{LightGraphs.SimpleGraphs.SimpleEdge{Int64}}:\n Edge 1 => 2\n Edge 2 => 3\n Edge 3 => 2\n\n\n\n\n\n","category":"method"}]
}
